---
title: Features
last_reviewed_on: 2025-10-02
review_in: 6 weeks
---

# Features

## Asset management
This template uses [ESBuild](https://esbuild.github.io/) for asset bundling and management, providing fast builds and efficient handling of JavaScript, TypeScript, and SCSS files.

## Cache busting
Caching allows Express applications to store and serve frequently requested data efficiently, reducing the strain on servers and minimizing latency. This template improves caching through:

- intelligent browser caching, when using the template for development of an application
- employing a package management tool, to improve the caching process of installing, upgrading, configuring, and removing software from your application

## Advanced Schema Validation
This template provides comprehensive form validation using express-validator with advanced patterns for complex data structures, error handling, and user experience.

### Production-Ready Validation Features
- **Complex data validation** - Date fields, conditional logic, cross-field validation
- **Type-safe error handling** - TypeScript integration with proper error types
- **Internationalised messages** - Multi-language support with i18n integration
- **Session integration** - Change detection and form state management
- **Accessibility compliance** - WCAG-compliant error messaging and form handling

### Schema Validation Patterns
The template demonstrates advanced validation patterns extracted from production LAA applications:

```typescript
// middleware/personSchema.ts
import { body } from 'express-validator';
import { createSessionChangeDetectionValidator } from '#src/scripts/helpers/index.js';

export const personValidationSchema = [
  // Basic field validation with i18n messages
  body('firstName')
    .trim()
    .notEmpty()
    .withMessage('validation.firstName.required')
    .isLength({ max: 50 })
    .withMessage('validation.firstName.maxLength'),
    
  // Complex date validation with cross-field logic
  body(['dateOfBirth.day', 'dateOfBirth.month', 'dateOfBirth.year'])
    .custom((value, { req }) => {
      return validateDateFields(req.body.dateOfBirth);
    })
    .withMessage('validation.dateOfBirth.invalid'),
    
  // Session change detection
  createSessionChangeDetectionValidator('person')
];
```

### Advanced Error Handling
Type-safe error processing with internationalisation:

```typescript
// controllers/personController.ts
import { validationResult } from 'express-validator';
import { TypedValidationError, formatValidationErrors } from '#src/scripts/helpers/index.js';

export const processPerson = (req: Request, res: Response): void => {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    const formattedErrors = formatValidationErrors(
      errors.array() as TypedValidationError[],
      req.t
    );
    
    return res.render('person/form', {
      errors: formattedErrors,
      formData: req.body
    });
  }
  
  // Process valid data...
};
```

### Helper Functions for Complex Validation
The template includes production-tested helper functions:

```typescript
// Data transformation helpers
safeBodyString(req.body, 'fieldName') // Safe string extraction
isRecord(data) // Type-safe object checking
hasProperty(obj, 'prop') // Property existence validation

// Date validation helpers  
validateDateFields(dateObject) // Complete date validation
formatDateErrors(errors, translator) // Accessible error messages

// Session helpers
detectChanges(current, previous) // Form change detection
updateSessionData(req, data) // Safe session updates
```

### Key Benefits
- **Production-proven patterns** from live LAA applications
- **Accessibility-first approach** with proper error associations
- **Type safety** throughout validation pipeline  
- **Internationalisation ready** with translation integration
- **Complex validation logic** for real-world form requirements
- **Performance optimised** with efficient validation chains

For detailed implementation examples, see the [Schema Validation Guide](script-helpers.html) documentation.

## CSRF protection
The template uses the [csrf-sync](https://www.npmjs.com/package/csrf-sync/v/1.0.2) middleware, to help keep your app secure.

## Content Security Policy (CSP)
This template uses [helmet.js](https://helmetjs.github.io/) to help secure this Express template app by setting HTTP response headers, which includes your CSP. 

## Response compression
The template uses a Node.js compression middleware called [compression](https://www.npmjs.com/package/compression). The middleware will attempt to compress response bodies for all request that traverse through the middleware, based on the given options.


## Rate limiting
This template uses a basic rate-limiting middleware for Express, called `express-rate-limit`. It is used to limit repeated requests to public APIs and/or endpoints such as password reset. 

For further information please [visit the documentation here](https://www.npmjs.com/package/express-rate-limit?activeTab=readme).

## Linter
ESLint is a static code analysis tool for identifying and fixing problems in JavaScript and TypeScript code. It helps maintain code quality and consistency across a project by enforcing a set of coding standards and best practices. ESLint can catch syntax errors, stylistic issues, and potential bugs before they become actual problems.

The template has TypeScript support through the `@typescript-eslint/eslint-plugin` and `@typescript-eslint/parser` packages installed as dev dependencies.

To run ESLint:

```shell
yarn lint
```

This will run ESLint on all TypeScript files in your project, ignoring specific files and directories.

### Ignore Configuration

The template configures ESLint to ignore certain files directly in the `eslint.config.js` file:

```javascript
{
  ignores: [
    'node_modules/*',
    'public/*',
    'tests/**/*.spec.ts'
  ],
}
```

This configuration:

- Ignores the `node_modules` directory
- Ignores the `public` directory (generated output)
- Ignores all test specification files (`*.spec.ts`) in any subdirectory of the `tests` folder

## Linter for staged commits
We use [husky](https://github.com/typicode/husky) & [lint-staged](https://github.com/lint-staged/lint-staged) to run ESLint on all our staged git commits. This ensures that TypeScript files are linted before they're committed to the repository.

- `husky` - helps us with our Git hooks
- `lint-staged` - helps us run a linter on our staged commits (configured in package.json to target both .js and .ts files)


**To set-up locally**
- Install all the dependencies:
```shell
yarn install
```

- Initialise `husky`:
```shell
yarn husky install
```

- To help debug, run the command when you have a staged commit:
```shell
yarn lint-staged --debug
```

## TypeScript
This template uses TypeScript to provide static type checking, improving code quality and developer experience. TypeScript helps catch errors during development rather than at runtime and provides better IDE support through enhanced autocompletion and navigation.

### Main TypeScript Configuration
The TypeScript configuration is defined in `tsconfig.json` with the following key settings:

- Target: ES2022
- Module System: NodeNext
- Strict Type Checking: Enabled
- Source Maps: Generated for debugging

### Test TypeScript Configuration
The template uses a separate TypeScript configuration for tests in `tsconfig.test.json`, which extends the main configuration:

```json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "module": "NodeNext",
    "moduleResolution": "NodeNext"
  },
  "include": ["tests/**/*.spec.ts", "routes/**/*.ts", "src/**/*.ts", "middleware/**/*.ts", "utils/**/*.ts"]
}
```

This configuration:

- Extends the main `tsconfig.json`
- Allows importing TypeScript files with extensions (`.ts`)
- Doesn't emit compiled output files when running tests
- Includes all test files (`*.spec.ts`) in all test subdirectories
- Includes source files from routes, src, middleware, and utils directories that tests may need to reference

To compile TypeScript files:
```shell
yarn build:ts
```

To run type checking without emitting files:
```shell
yarn tsc
```

## Type definitions
- Type definitions for Node, Express, and other dependencies are included as dev dependencies (see `@types/*` packages in `package.json`).
- These are required for type safety and improved autocompletion in TypeScript.


## Axios
Within this template [axios](https://github.com/axios/axios) with [middleware-axios](https://github.com/krutoo/middleware-axios) (used as a utility `../utils/axiosSetup.ts`, and can be extended with further middleware) is set up and ready to use out of the box.

Below is an example of implementation and how to use the Axios middleware in your TypeScript routes to make server/API calls:

```typescript
// routes/index.ts
import express, { Request, Response, NextFunction } from 'express';
const router = express.Router();

/* GET home page. */
router.get('/', (req: Request, res: Response, next: NextFunction) => {
  res.render('main/index', { title: 'Express' });
});

// Make an API call with `Axios` and `middleware-axios`
// GET users from external API
router.get('/users', async (req: Request, res: Response, next: NextFunction) => {
  try {
    // Use the wrapped Axios instance attached to the request object (via middleware-axios)
    const response = await req.axiosMiddleware.get('https://jsonplaceholder.typicode.com/users');
    res.json(response.data);
  } catch (error) {
    next(error);
  }
});

export default router;
```

## Nunjucks templating
This template uses [Nunjucks](https://mozilla.github.io/nunjucks/) for server-side HTML templating. You can render Nunjucks templates from your TypeScript route handlers just as you would from JavaScript. Templates are located in the `views/` directory and are compatible with both JS and TS backends.
