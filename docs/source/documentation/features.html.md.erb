------

title: Features and Architecturetitle: Features

last_reviewed_on: 2025-10-13last_reviewed_on: 2025-10-02

review_in: 6 weeksreview_in: 6 weeks

------



# Features and Architecture# Features



This template provides a comprehensive set of features for building secure, maintainable Express.js applications with TypeScript.## Asset management

This template uses [ESBuild](https://esbuild.github.io/) for asset bundling and management, providing fast builds and efficient handling of JavaScript, TypeScript, and SCSS files.

## Core Features

## Cache busting

### RoutingCaching allows Express applications to store and serve frequently requested data efficiently, reducing the strain on servers and minimizing latency. This template improves caching through:



This template uses the built-in Express JS routing. - intelligent browser caching, when using the template for development of an application

- employing a package management tool, to improve the caching process of installing, upgrading, configuring, and removing software from your application

A route is a section of Express code that associates an HTTP verb (`GET`, `POST`, `PUT`, `DELETE`, etc.), with a URL path/pattern, and a function that is called to handle that pattern.

## Form validation

[You can find further documentation here](https://expressjs.com/en/guide/routing.html).This template app contains a basic demo for form validation, when running this app locally. You can find further information on the validation used, by searching in the [Express documentation](https://www.npmjs.com/package/express-validator)



### Asset management## CSRF protection

The template uses the [csrf-sync](https://www.npmjs.com/package/csrf-sync/v/1.0.2) middleware, to help keep your app secure.

This project uses [ESBuild](https://esbuild.github.io/) for asset bundling and management, providing fast builds and efficient handling of JavaScript, TypeScript, and SCSS files.

## Content Security Policy (CSP)

### Cache bustingThis template uses [helmet.js](https://helmetjs.github.io/) to help secure this Express template app by setting HTTP response headers, which includes your CSP. 



Caching allows Express.js applications to store and serve frequently requested data efficiently, reducing the strain on servers and minimizing latency. This template improves caching through:## Response compression

- intelligent browser caching, when using the template for development of an applicationThe template uses a Node.js compression middleware called [compression](https://www.npmjs.com/package/compression). The middleware will attempt to compress response bodies for all request that traverse through the middleware, based on the given options.

- employing a package management tool, to improve the caching process of installing, upgrading, configuring, and removing software from your application



### Form validation## Rate limiting

This template uses a basic rate-limiting middleware for Express, called `express-rate-limit`. It is used to limit repeated requests to public APIs and/or endpoints such as password reset. 

This template app contains a basic demo for form validation, when running this app locally. You can find further information on the validation used, by searching in the [Express documentation](https://www.npmjs.com/package/express-validator)

For further information please [visit the documentation here](https://www.npmjs.com/package/express-rate-limit?activeTab=readme).

## Security Features

## Linter

### CSRF protectionESLint is a static code analysis tool for identifying and fixing problems in JavaScript and TypeScript code. It helps maintain code quality and consistency across a project by enforcing a set of coding standards and best practices. ESLint can catch syntax errors, stylistic issues, and potential bugs before they become actual problems.



The template uses the [csrf-sync](https://www.npmjs.com/package/csrf-sync/v/1.0.2) middleware, to help keep your app secure.The template has TypeScript support through the `@typescript-eslint/eslint-plugin` and `@typescript-eslint/parser` packages installed as dev dependencies.



### Content Security Policy (CSP)To run ESLint:



This app uses [helmet.js](https://helmetjs.github.io/) to help secure this Express.js template app by setting HTTP response headers, which includes your CSP. ```shell

yarn lint

### Response compression```



The app uses a Node.js compression middleware called [compression](https://www.npmjs.com/package/compression). The middleware will attempt to compress response bodies for all request that traverse through the middleware, based on the given options.This will run ESLint on all TypeScript files in your project, ignoring specific files and directories.



### Rate limiting### Ignore Configuration



This template uses a basic rate-limiting middleware for Express.js, called `express-rate-limit`. It is used to limit repeated requests to public APIs and/or endpoints such as password reset. The template configures ESLint to ignore certain files directly in the `eslint.config.js` file:



For further information please [visit the documentation here](https://www.npmjs.com/package/express-rate-limit?activeTab=readme).```javascript

{

## Development Tools  ignores: [

    'node_modules/*',

### Linter    'public/*',

    'tests/**/*.spec.ts'

ESLint is a static code analysis tool for identifying and fixing problems in JavaScript and TypeScript code. It helps maintain code quality and consistency across a project by enforcing a set of coding standards and best practices. ESLint can catch syntax errors, stylistic issues, and potential bugs before they become actual problems.  ],

}

The project has TypeScript support through the `@typescript-eslint/eslint-plugin` and `@typescript-eslint/parser` packages installed as dev dependencies.```



To run ESLint:This configuration:



```shell- Ignores the `node_modules` directory

yarn lint- Ignores the `public` directory (generated output)

```- Ignores all test specification files (`*.spec.ts`) in any subdirectory of the `tests` folder



This will run ESLint on all TypeScript files in your project, ignoring specific files and directories.## Linter for staged commits

We use [husky](https://github.com/typicode/husky) & [lint-staged](https://github.com/lint-staged/lint-staged) to run ESLint on all our staged git commits. This ensures that TypeScript files are linted before they're committed to the repository.

#### Ignore Configuration

- `husky` - helps us with our Git hooks

The project configures ESLint to ignore certain files directly in the `eslint.config.js` file:- `lint-staged` - helps us run a linter on our staged commits (configured in package.json to target both .js and .ts files)



```javascript

{**To set-up locally**

  ignores: [- Install all the dependencies:

    'node_modules/*',```shell

    'public/*',yarn install

    'tests/**/*.spec.ts'```

  ],

}- Initialise `husky`:

``````shell

yarn husky install

This configuration:```

- Ignores the `node_modules` directory

- Ignores the `public` directory (generated output)- To help debug, run the command when you have a staged commit:

- Ignores all test specification files (`*.spec.ts`) in any subdirectory of the `tests` folder```shell

yarn lint-staged --debug

### Linter for staged commits```



We use [husky](https://github.com/typicode/husky) & [lint-staged](https://github.com/lint-staged/lint-staged) to run ESLint on all our staged git commits. This ensures that TypeScript files are linted before they're committed to the repository.## TypeScript

This template uses TypeScript to provide static type checking, improving code quality and developer experience. TypeScript helps catch errors during development rather than at runtime and provides better IDE support through enhanced autocompletion and navigation.

- `husky` - helps us with our Git hooks

- `lint-staged` - helps us run a linter on our staged commits (configured in package.json to target both .js and .ts files)### Main TypeScript Configuration

The TypeScript configuration is defined in `tsconfig.json` with the following key settings:

**To set-up locally**

- Install all the dependencies:- Target: ES2022

```shell- Module System: NodeNext

yarn install- Strict Type Checking: Enabled

```- Source Maps: Generated for debugging



- Initialise `husky`:### Test TypeScript Configuration

```shellThe template uses a separate TypeScript configuration for tests in `tsconfig.test.json`, which extends the main configuration:

yarn husky install

``````json

{

- To help debug, run the command when you have a staged commit:  "extends": "./tsconfig.json",

```shell  "compilerOptions": {

yarn lint-staged --debug    "allowImportingTsExtensions": true,

```    "noEmit": true,

    "module": "NodeNext",

## TypeScript Configuration    "moduleResolution": "NodeNext"

  },

This project uses TypeScript to provide static type checking, improving code quality and developer experience. TypeScript helps catch errors during development rather than at runtime and provides better IDE support through enhanced autocompletion and navigation.  "include": ["tests/**/*.spec.ts", "routes/**/*.ts", "src/**/*.ts", "middleware/**/*.ts", "utils/**/*.ts"]

}

### Main TypeScript Configuration```



The TypeScript configuration is defined in `tsconfig.json` with the following key settings:This configuration:

- Target: ES2022

- Module System: NodeNext- Extends the main `tsconfig.json`

- Strict Type Checking: Enabled- Allows importing TypeScript files with extensions (`.ts`)

- Source Maps: Generated for debugging- Doesn't emit compiled output files when running tests

- Includes all test files (`*.spec.ts`) in all test subdirectories

### Test TypeScript Configuration- Includes source files from routes, src, middleware, and utils directories that tests may need to reference



The project uses a separate TypeScript configuration for tests in `tsconfig.test.json`, which extends the main configuration:To compile TypeScript files:

```shell

```jsonyarn build:ts

{```

  "extends": "./tsconfig.json",

  "compilerOptions": {To run type checking without emitting files:

    "allowImportingTsExtensions": true,```shell

    "noEmit": true,yarn tsc

    "module": "NodeNext",```

    "moduleResolution": "NodeNext"

  },## Type definitions

  "include": ["tests/**/*.spec.ts", "routes/**/*.ts", "src/**/*.ts", "middleware/**/*.ts", "utils/**/*.ts"]- Type definitions for Node, Express, and other dependencies are included as dev dependencies (see `@types/*` packages in `package.json`).

}- These are required for type safety and improved autocompletion in TypeScript.

```



This configuration:## API Connection Patterns

- Extends the main `tsconfig.json`This template provides generalized API connection patterns extracted from MCC's (Manage Your Civil Cases) production-tested codebase. The patterns offer a robust foundation for HTTP client functionality without forcing specific response formats or domain logic.

- Allows importing TypeScript files with extensions (`.ts`)

- Doesn't emit compiled output files when running tests### Enhanced Axios Middleware

- Includes all test files (`*.spec.ts`) in all test subdirectoriesThe template includes enhanced axios middleware with:

- Includes source files from routes, src, middleware, and utils directories that tests may need to reference

- **Configurable instances** - Create axios instances with custom timeout, headers, and base URLs

To compile TypeScript files:- **Authentication support** - Optional JWT/token handling with automatic refresh on 401 responses  

```shell- **Request/response logging** - Environment-aware logging with JSON pretty-printing for debugging

yarn build:ts- **Error handling** - Standardized error extraction and user-friendly message transformation

```

```typescript

To run type checking without emitting files:// Basic usage (existing pattern still works)

```shellrouter.get('/users', async (req: Request, res: Response, next: NextFunction) => {

yarn tsc  try {

```    const response = await req.axiosMiddleware.get('https://api.example.com/users');

    res.json(response.data);

## HTTP Client  } catch (error) {

    next(error);

### Axios  }

});

Within this template [axios](https://github.com/axios/axios) with [middleware-axios](https://github.com/krutoo/middleware-axios) (used as a utility `../utils/axiosSetup.ts`, and can be extended with further middleware) is set up and ready to use out of the box.

// Enhanced usage with custom configuration

Below is an example of implementation of how to use the Axios middleware in your TypeScript routes to make server/API calls:import { createApiMiddleware } from '#utils/axiosSetup.js';



```typescriptconst apiMiddleware = createApiMiddleware({

// routes/index.ts  timeout: 10000,

import express, { Request, Response, NextFunction } from 'express';  defaultHeaders: { 'Content-Type': 'application/json' },

const router = express.Router();  enableLogging: true,

  authService: myAuthService // Optional authentication

/* GET home page. */});

router.get('/', (req: Request, res: Response, next: NextFunction) => {```

  res.render('main/index', { title: 'Express' });

});### BaseApiService Pattern

For more complex API integrations, the template provides a `BaseApiService` abstract class that extracts common HTTP client patterns:

// Make an API call with `Axios` and `middleware-axios`

// GET users from external API```typescript

router.get('/users', async (req: Request, res: Response, next: NextFunction) => {// Create your own API service

  try {import { BaseApiService } from '#src/services/BaseApiService.js';

    // Use the wrapped Axios instance attached to the request object (via middleware-axios)

    const response = await req.axiosMiddleware.get('https://jsonplaceholder.typicode.com/users');class MyApiService extends BaseApiService {

    res.json(response.data);  constructor() {

  } catch (error) {    super({

    next(error);      baseUrl: process.env.MY_API_URL,

  }      apiPrefix: '/v1',

});      timeout: 10000,

      enableLogging: true

export default router;    });

```  }



## Package Management  async getUsers(axiosWrapper: AxiosInstanceWrapper) {

    return this.get(axiosWrapper, '/users');

### Yarn  }



This project uses [Yarn](https://yarnpkg.com/) rather than the native package manager NPM to improve performance & security for more reliable dependency management.  async createUser(axiosWrapper: AxiosInstanceWrapper, userData: unknown) {

    return this.post(axiosWrapper, '/users', userData);

#### How to run manual updates  }

}

Dependabot will routinely check your project packages to find any updates. However, you can use the following command to run manual updates:

// Use in routes

```shellconst myApiService = new MyApiService();

yarn upgrade-interactive

```router.get('/users', async (req: Request, res: Response, next: NextFunction) => {

  try {

#### Sources    const response = await myApiService.getUsers(req.axiosMiddleware);

    res.json(response.data);

[yarn upgrade-interactive](https://yarnpkg.com/cli/upgrade-interactive#details)  } catch (error) {

    next(error);

## Template Engine  }

});

### Nunjucks templating```



This project uses [Nunjucks](https://mozilla.github.io/nunjucks/) for server-side HTML templating. You can render Nunjucks templates from your TypeScript route handlers just as you would from JavaScript. Templates are located in the `views/` directory and are compatible with both JS and TS backends.### Key Benefits

- **Production-tested patterns** extracted from LAA's MCC application

## Project Structure- **Scalable architecture** - from simple API calls to complex authentication flows

- **Comprehensive logging** - request/response logging with error context

### Project structure and source directory- **Type-safe** - Full TypeScript support with proper type definitions



- Project-specific TypeScript code should go in `src/scripts/`.## Nunjucks templating

- Other source TypeScript files are located in `src/`, `middleware/`, `routes/`, and `utils/`.This template uses [Nunjucks](https://mozilla.github.io/nunjucks/) for server-side HTML templating. You can render Nunjucks templates from your TypeScript route handlers just as you would from JavaScript. Templates are located in the `views/` directory and are compatible with both JS and TS backends.

- Compiled JavaScript output is placed in the `public/` directory.
- Do not edit files in `public/` directly; always edit the `.ts` source files.

### Import paths and path aliases

- The project uses path aliases (see `tsconfig.json`), such as `import foo from '#utils/foo'`.
- Ensure your editor/IDE is configured to recognize these aliases for best developer experience.

### Running and debugging

- The app is started using the compiled JS in `public/` (see `yarn dev` and `yarn start`).
- If you want to run TypeScript directly (e.g., for debugging), consider using `ts-node` or a similar tool, but this is not the default workflow.

## Development Workflow

The project uses ESBuild for fast compilation and bundling with watch mode for automatic rebuilds during development. The development workflow is managed through the `yarn dev` script which concurrently runs:

1. **TypeScript compilation in watch mode** - Monitors TypeScript source files for changes
2. **ESBuild bundling in watch mode** - Handles SCSS, JavaScript bundling, and asset copying
3. **Nodemon for server restarts** - Automatically restarts the Express server when compiled files change

The watch system monitors:
- TypeScript source files (`src/**/*.ts`) for compilation
- SCSS files (`src/scss/**/*.scss`) for CSS bundling
- Asset files from GOV.UK Frontend and MOJ Frontend packages
- The compiled output in the `public/` directory for server restarts

Nodemon configuration (`nodemon.json`):
```json
{
  "watch": ["public"],
  "ext": "js,json",
  "ignore": ["public/assets/"],
  "delay": "500ms"
}
```

This configuration:
- Watches the `public` directory for changes in compiled output
- Only monitors changes in `.js` and `.json` files
- Ignores the `public/assets/` directory (managed by ESBuild)
- Adds a 500ms delay before restarting to avoid excessive restarts during rapid file changes

The development workflow is started with:
```shell
yarn dev
```

This command builds the project initially and then sets up all watch processes for continuous development.

### Type definitions

- Type definitions for Node, Express, and other dependencies are included as dev dependencies (see `@types/*` packages in `package.json`).
- These are required for type safety and improved autocompletion in TypeScript.